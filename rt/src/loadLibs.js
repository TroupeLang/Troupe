'use strict'
const fs = require('fs');

const logger = require('./logger.js').mkLogger('lib');
const info = x => logger.info(x)
const debug = x => logger.debug(x)

const __libcache = {}

function loadLibsAsync(libs, obj, cb, rtObj) {
  function iterateAsync(n) {
    if (n < libs.length) {
      let lib = libs[n].lib;
      let decl = libs[n].decl;

      const key = lib +"." + decl
      if (__libcache[key]) {
        debug ('lib cache hit on: ' + key)
        obj.libs[key]=__libcache[key];
        setImmediate(iterateAsync, n + 1);
        return;
      }

      // 1. Find the file -- note that we load all the libs from a default
      //    location

      let filename = process.env.TROUPE +  "/lib/out/" + lib + ".js"

      

      // 2. Load the file -- note that this is an asynchronous operation
      fs.readFile(filename, 'utf8', (err, input) => {
        
        // File read operation finished; we are now in the callbacak that has
        // been asynchronously called by the node runtime 
        
        // TODO: check for error! 2018-07-03: aa

        // 3. Create a JS class (function) from it
        let Lib = new Function('rt', input);

        // 4. We create a "new" instance of the resulting class

        let libinstance = new Lib(rtObj);


        // load dependent libraries??
        
        libinstance.loadlibs (() =>  {
          // 5. Execute .export() function to obtain the table note - this is a
          //    regular JS function (generated by the compiler) that we just call
          //    here 

          rtObj.setLibloadMode(); // 2019-01-03: AA; Hack
          let table = libinstance.export().val.toArray();
          rtObj.setNormalMode();  // 2019-01-03: AA; EOH

          // 6. Lookup in the resulting table

          for (let i = 0; i < table.length; i++) {
            let name = table[i].val[0].val;
            let libf = table[i].val[1].val
            if (name == decl) {
              // We store the resulting function in the object that was provided
              // to us as an argument 
              obj.libs[key] = libf;
              __libcache [key] = libf;
              break;
            }
          }

          // Next iteration
          iterateAsync (n + 1);
        })
      })
      
    } else {
      // We are done processing the lib files. Transferring control back to the
      // callback. The callback is either 
      //
      // a. The next thing in the initialization, if this is the first time we
      //    are loading libraries -- typically scheduler init, etc (see `start`
      //    function in the runtime), OR
      //
      // b. The next iteration in deserialization, which is more library loading
      //    when we have several namespaces, or whatever is the deserialization
      //    callback (see `mkValue` function in the serialize module).

      cb();
    }
  }
  iterateAsync (0);
}

module.exports = {
  loadLibsAsync: loadLibsAsync
}