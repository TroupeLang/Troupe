'use strict'
import * as fs from 'node:fs'
import * as levels from './levels/tagsets.mjs';
const { readFile } = fs.promises

import { mkLogger } from './logger.mjs'
const logger = mkLogger('lib')

const info = x => logger.info(x)
const debug = x => logger.debug(x)

const __libcache = {}

export async function loadLibsAsync(obj, rtObj) {
    let libs = obj.libs
    obj.libs = {}
    for (let n = 0; n < libs.length; n++) {
        let lib = libs[n].lib;
        let decl = libs[n].decl;

        const key = lib + "." + decl
        if (__libcache[key]) {
            debug('lib cache hit on: ' + key)
            obj.libs[key] = __libcache[key];
            continue
        }

        // 1. Find the file -- note that we load all the libs from a default
        //    location

        let filename = process.env.TROUPE + "/lib/out/" + lib + ".js"

        // 2. Load the file -- note that this is an asynchronous operation
        let input = await readFile(filename, 'utf8')

        // File read operation finished; we are now in the callbacak that has
        // been asynchronously called by the node runtime 

        // TODO: check for error! 2018-07-03: aa

        // 3. Create a JS class (function) from it
        let Lib: any = new Function('rt', input);

        // 4. We create a "new" instance of the resulting class

        let libinstance = new Lib(rtObj);


        // load dependent libraries??

        // libinstance.loadlibs (() => 
        await loadLibsAsync(libinstance, rtObj)

        // 5. Execute .export() function to obtain the table note - this is a
        //    regular JS function (generated by the compiler) that we just call
        //    here 

        rtObj.setLibloadMode(); // 2019-01-03: AA; Hack
        let table = libinstance.export({__dataLevel:levels.BOT}).val.toArray();
        rtObj.setNormalMode();  // 2019-01-03: AA; EOH

        // 6. Lookup in the resulting table

        for (let i = 0; i < table.length; i++) {
            let name = table[i].val[0].val;
            let libf = table[i].val[1].val
            if (name == decl) {
                // We store the resulting function in the object that was provided
                // to us as an argument 
                obj.libs[key] = libf;
                __libcache[key] = libf;
                break;
            }
        }
    }
}
