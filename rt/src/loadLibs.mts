/* 2020-05-19: AA This code is deprecated */

'use strict'

import * as fs from 'node:fs'

import { mkLogger } from './logger.mjs'
const logger = mkLogger('lib')

const info = x => logger.info(x)
const debug = x => logger.debug(x)

const __libcache = {}

export function loadLibsAsync(obj, rtObj, cb) {
  let libs = obj.libs
  obj.libs = {}
  function iterateAsync(n) {
    if (n < libs.length) {
      let lib = libs[n].lib;
      let decl = libs[n].decl;

      const key = lib +"." + decl
      if (__libcache[key]) {
        debug ('lib cache hit on: ' + key)
        obj.libs[key]=__libcache[key];
        setImmediate(iterateAsync, n + 1);
        return;
      }

      // 1. Find the file -- note that we load all the libs from a default
      //    location

      let filename = process.env.TROUPE +  "/lib/out/" + lib + ".js"

      

      // 2. Load the file -- note that this is an asynchronous operation
      fs.readFile(filename, 'utf8', (err, input) => {
        
        // File read operation finished; we are now in the callbacak that has
        // been asynchronously called by the node runtime 
        
        // TODO: check for error! 2018-07-03: aa

        // 3. Create a JS class (function) from it
        let Lib:any = new Function('rt', input);

        // 4. We create a "new" instance of the resulting class

        let libinstance = new Lib(rtObj);


        // load dependent libraries??
        
        // libinstance.loadlibs (() => 
        loadLibsAsync(libinstance, rtObj, () => {
          // 5. Execute .export() function to obtain the table note - this is a
          //    regular JS function (generated by the compiler) that we just call
          //    here 

          rtObj.setLibloadMode(); // 2019-01-03: AA; Hack
          let table = libinstance.export().val.toArray();
          rtObj.setNormalMode();  // 2019-01-03: AA; EOH

          // 6. Lookup in the resulting table

          for (let i = 0; i < table.length; i++) {
            let name = table[i].val[0].val;
            let libf = table[i].val[1].val
            if (name == decl) {
              // We store the resulting function in the object that was provided
              // to us as an argument 
              obj.libs[key] = libf;
              __libcache [key] = libf;
              break;
            }
          }

          // Next iteration
          iterateAsync (n + 1);
        })
      })
      
    } else {
      // We are done processing the lib files. Transferring control back to the
      // callback. The callback is either 
      //
      // a. The next thing in the initialization, if this is the first time we
      //    are loading libraries -- typically scheduler init, etc (see `start`
      //    function in the runtime), OR
      //
      // b. The next iteration in deserialization, which is more library loading
      //    when we have several namespaces, or whatever is the deserialization
      //    callback (see `mkValue` function in the serialize module).

      cb();
    }
  }
  iterateAsync (0);
}
